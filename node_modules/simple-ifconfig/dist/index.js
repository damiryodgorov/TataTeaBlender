"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.NetworkInfo = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _debug = _interopRequireDefault(require("debug"));

var _child_process = require("child_process");

var BASE_16 = 16,
    CHAR_ADVANCE = 2,
    debug = (0, _debug["default"])('simple-ifconfig'),
    DEFAULT_ACTIVE_DOWN = 'down',
    DEFAULT_ACTIVE_UP = 'up',
    DEFAULT_HARDWARE_ADDR = '00:00:00:00:00:00',
    DEFAULT_METRIC = 99,
    DEFAULT_OPTIONS = {
  active: true,
  ifconfigPath: '/sbin/ifconfig',
  internal: false,
  verbose: true
},
    RE_DELIM = /\ |\:/,
    // http://www-01.ibm.com/support/docview.wss?uid=isg3T1019709
// http://docs.oracle.com/cd/E19253-01/816-5166/6mbb1kq31/#INTERFACE%20FLAGS
RE_FLAGS = {
  addrconf: /(^|[\ \t\,]*)addrconf($|[\ \t\,]*)/i,
  allmulti: /(^|[\ \t\,]*)allmulti($|[\ \t\,]*)/i,
  anycast: /(^|[\ \t\,]*)anycast($|[\ \t\,]*)/i,
  broadcast: /(^|[\ \t\,]*)broadcast($|[\ \t\,]*)/i,
  cluif: /(^|[\ \t\,]*)cluif($|[\ \t\,]*)/i,
  cos: /(^|[\ \t\,]*)cos($|[\ \t\,]*)/i,
  debug: /(^|[\ \t\,]*)debug($|[\ \t\,]*)/i,
  deprecated: /(^|[\ \t\,]*)deprecated($|[\ \t\,]*)/i,
  dhcp: /(^|[\ \t\,]*)dhcp($|[\ \t\,]*)/i,
  duplicate: /(^|[\ \t\,]*)duplicate($|[\ \t\,]*)/i,
  failed: /(^|[\ \t\,]*)failed($|[\ \t\,]*)/i,
  fixedmtu: /(^|[\ \t\,]*)fixedmtu($|[\ \t\,]*)/i,
  grouprt: /(^|[\ \t\,]*)grouprt($|[\ \t\,]*)/i,
  inactive: /(^|[\ \t\,]*)inactive($|[\ \t\,]*)/i,
  loopback: /(^|[\ \t\,]*)loopback($|[\ \t\,]*)/i,
  mip: /(^|[\ \t\,]*)mip($|[\ \t\,]*)/i,
  multibcast: /(^|[\ \t\,]*)multi_bcast($|[\ \t\,]*)/i,
  multicast: /(^|[\ \t\,]*)multicast($|[\ \t\,]*)/i,
  multinet: /(^|[\ \t\,]*)multinet($|[\ \t\,]*)/i,
  noarp: /(^|[\ \t\,]*)noarp($|[\ \t\,]*)/i,
  nochecksum: /(^|[\ \t\,]*)nochecksum($|[\ \t\,]*)/i,
  nofailover: /(^|[\ \t\,]*)nofailover($|[\ \t\,]*)/i,
  nolocal: /(^|[\ \t\,]*)nolocal($|[\ \t\,]*)/i,
  nonud: /(^|[\ \t\,]*)nonud($|[\ \t\,]*)/i,
  nortexch: /(^|[\ \t\,]*)notexch($|[\ \t\,]*)/i,
  notrailers: /(^|[\ \t\,]*)notrailers($|[\ \t\,]*)/i,
  noxmit: /(^|[\ \t\,]*)noxmit($|[\ \t\,]*)/i,
  oactive: /(^|[\ \t\,]*)oactive($|[\ \t\,]*)/i,
  offline: /(^|[\ \t\,]*)offline($|[\ \t\,]*)/i,
  pfcopyall: /(^|[\ \t\,]*)pfcopyall($|[\ \t\,]*)/i,
  pointopoint: /(^|[\ \t\,]*)pointopoint($|[\ \t\,]*)/i,
  preferred: /(^|[\ \t\,]*)preferred($|[\ \t\,]*)/i,
  "private": /(^|[\ \t\,]*)private($|[\ \t\,]*)/i,
  promisc: /(^|[\ \t\,]*)promisc($|[\ \t\,]*)/i,
  pseg: /(^|[\ \t\,]*)pseg($|[\ \t\,]*)/i,
  quorumloss: /(^|[\ \t\,]*)quorumloss($|[\ \t\,]*)/i,
  router: /(^|[\ \t\,]*)router($|[\ \t\,]*)/i,
  running: /(^|[\ \t\,]*)running($|[\ \t\,]*)/i,
  simplex: /(^|[\ \t\,]*)simplex($|[\ \t\,]*)/i,
  smart: /(^|[\ \t\,]*)smart($|[\ \t\,]*)/i,
  standby: /(^|[\ \t\,]*)standby($|[\ \t\,]*)/i,
  temporary: /(^|[\ \t\,]*)temporary($|[\ \t\,]*)/i,
  unnumbered: /(^|[\ \t\,]*)unnumbered($|[\ \t\,]*)/i,
  up: /(^|[\ \t\,]*)up($|[\ \t\,]*)/i,
  varmtu: /(^|[\ \t\,]*)var\_mtu($|[\ \t\,]*)/i,
  virtual: /(^|[\ \t\,]*)virtual($|[\ \t\,]*)/i,
  xresolv: /(^|[\ \t\,]*)xresolv($|[\ \t\,]*)/i
},
    RE_HARDWARE_ADDR = /(ether|hwaddr)\ +(([0-9a-f]{2}[\:\-]{0,1}){6})/i,
    RE_IFCONFIG_FLAGS = /<?([a-z\,\ \t\_]*)\>?(([\ \t]*mtu[\:\ \t]+[0-9]+)|([\ \t]*metric[\:\ \t]+[0-9]+)|([\ \t]*index[\:\ \t]+[0-9]+))+/i,
    RE_IFCONFIG_IPV4 = /^\s*inet\s/,
    RE_IFCONFIG_IPV6 = /^\s*inet6\s/,
    RE_INDEX = /index[\ \:]+[0-9]+/i,
    RE_LINUX_ADDR = /^addr\:/i,
    RE_LINUX_BCAST = /^bcast\:/i,
    RE_LINUX_MASK = /^mask\:/i,
    RE_METRIC = /metric[\ \:]+[0-9]+/i,
    RE_MTU = /mtu[\ \:]+[0-9]+/i,
    RE_NUMBER = /^[0-9]{2,}/,
    RE_STATUS = /^\s*(status)|((r|t)x\ bytes)/i,
    RE_UNIX_ADDR = /^inet$/i,
    RE_UNIX_BCAST = /^broadcast$/i,
    RE_UNIX_IPV6_ADDR = /^inet6$/i,
    RE_UNIX_IPV6_PREFIX_LENGTH = /^prefixlen$/i,
    RE_UNIX_MASK = /^netmask$/i,
    RE_UNIX_STATUS_ACTIVE = /\ active$/i,
    VERBOSE = '-v';

function _ensureDefaultOptions(networkInfo) {
  Object.getOwnPropertyNames(DEFAULT_OPTIONS).forEach(function (optionName) {
    debug('examining option %s (%s)', optionName, networkInfo.options[optionName]);

    if (_isNullOrUndefined(networkInfo.options[optionName])) {
      debug('applying default value for option %s (%o)', optionName, DEFAULT_OPTIONS[optionName]);
      networkInfo.options[optionName] = DEFAULT_OPTIONS[optionName];
    }
  });
}

function _ifconfig(networkInfo) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    var ifconfig = (0, _child_process.spawn)(networkInfo.options.ifconfigPath, args),
        stderr = [],
        stdout = []; // handle command exit

    ifconfig.on('close', function (code) {
      debug('%s %s command completed (code: %s)', networkInfo.options.ifconfigPath, args.join(' '), code);

      if (code) {
        var err = new Error(stderr.join(''));
        err.code = code;
        err.command = [networkInfo.options.ifconfigPath].concat(args).join(' ');
        return reject(err);
      }

      return resolve(stdout.join(''));
    }); // handle errors while attempting to execute command

    ifconfig.on('error', function (err) {
      err.command = [networkInfo.options.ifconfigPath].concat(args).join(' ');
      debug('%s command failed (error: %s)', err.command, err.message);
      return reject(err);
    }); // capture command output

    ifconfig.stdout.on('data', function (chunk) {
      return stdout.push(chunk);
    });
    ifconfig.stderr.on('data', function (chunk) {
      return stderr.push(chunk);
    });
  });
}

function _isNullOrUndefined(value) {
  return value === null || typeof value === 'undefined';
}

function _parseInterfaceInfo(networkInfo, ifconfigResult) {
  var addr,
      hardwareInterfaces = new Map(),
      iface,
      result = []; // break the ifconfig command result into lines and parse them 1 by 1...

  ifconfigResult.split(/\r?\n/).forEach(function (line) {
    var terms; // look for a new interface line

    if (!/\s/.test(line.charAt(0))) {
      // split the line on spaces (and optionally a colon)
      line = line.split(/\:?\ +/); // create new iface...

      iface = {
        active: false,
        hardwareAddress: DEFAULT_HARDWARE_ADDR,
        internal: true
      }; // assign the name using the first term in the line

      iface.name = line[0]; // ensure we have a valid interface

      if (!iface.name) {
        return;
      } // track the interface to return after processing


      hardwareInterfaces.set(iface.name, iface); // rebuild the line minus the adapter name and continue processing

      line = line.slice(1).join(' ');
    } // look for hardware address


    if (RE_HARDWARE_ADDR.test(line)) {
      terms = line.match(RE_HARDWARE_ADDR);
      debug('hardware address of %s found for interface %s', terms[2], iface.name);
      iface.hardwareAddress = terms[2];
      iface.internal = false;
    } // look for flag information and process


    if (RE_IFCONFIG_FLAGS.test(line)) {
      debug('interface flags found for interface %s (%s)', iface.name, line);
      iface.flags = {}; // map flags to the interface

      Object.keys(RE_FLAGS).forEach(function (flagName) {
        if (RE_FLAGS[flagName].test(line)) {
          debug('flag %s found for interface %s', flagName, iface.name);
          iface.flags[flagName] = true;
        }
      });

      if (RE_INDEX.test(line)) {
        terms = line.match(RE_INDEX)[0].split(RE_DELIM);
        debug('index of %d found for interface %s', terms[1], iface.name);
        iface.index = parseInt(terms[1], 10);
      }

      if (RE_METRIC.test(line)) {
        terms = line.match(RE_METRIC)[0].split(RE_DELIM);
        debug('metric of %d found for interface %s', terms[1], iface.name);
        iface.metric = parseInt(terms[1], 10);
      }

      if (RE_MTU.test(line)) {
        terms = line.match(RE_MTU)[0].split(RE_DELIM);
        debug('mtu of %d found for interface %s', terms[1], iface.name);
        iface.mtu = parseInt(terms[1], 10);
      }

      return;
    } // look for IPv4 info...


    if (RE_IFCONFIG_IPV4.test(line)) {
      debug('IPv4 information found for interface %s (%s)', iface.name, line);
      addr = {};
      iface.ipv4 = (iface.ipv4 || []).concat([addr]);
      terms = line.split(/\s+/);
      terms.forEach(function (term, i) {
        // linux formatting - addr:10.0.2.15
        if (RE_LINUX_ADDR.test(term)) {
          addr.address = term.split(RE_LINUX_ADDR)[1];
          return;
        } // linux formatting - Bcast:10.0.2.255


        if (RE_LINUX_BCAST.test(term)) {
          addr.broadcast = term.split(RE_LINUX_BCAST)[1];
          return;
        } // linux formatting - Mask:255.255.255.0


        if (RE_LINUX_MASK.test(term)) {
          addr.netmask = term.split(RE_LINUX_MASK)[1];
          return;
        } // unix formatting - address is 1st term


        if (RE_UNIX_ADDR.test(term)) {
          addr.address = terms[i + 1];
          return;
        } // unix formatting - netmask 0xffffff00


        if (RE_UNIX_MASK.test(term)) {
          var netmask = terms[i + 1]; // convert from hexidecimal if applicable

          if (/^0x/.test(netmask)) {
            // iterate 2 chars at a time converting from hex to decimal
            for (var _i = CHAR_ADVANCE; _i < netmask.length; _i += CHAR_ADVANCE) {
              addr.netmask = [addr.netmask || '', addr.netmask ? '.' : '', parseInt(['0x', netmask.slice(_i, _i + CHAR_ADVANCE)].join(''), BASE_16)].join('');
            }

            return;
          } // set netmask in teh event it is not in hexidecimal format


          addr.netmask = netmask;
          return;
        } // unix formatting - broadcast 10.129.8.255


        if (RE_UNIX_BCAST.test(term)) {
          addr.broadcast = terms[i + 1];
        }
      });
    } // look for IPv6 info


    if (RE_IFCONFIG_IPV6.test(line)) {
      debug('IPv6 information found for interface %s (%s)', iface.name, line);
      addr = {};
      iface.ipv6 = (iface.ipv6 || []).concat([addr]);
      terms = line.split(/\ +/);
      terms.some(function (term, i) {
        // check for linux address reference
        if (RE_LINUX_ADDR.test(term)) {
          terms = terms[i + 1].split(/\//);
          addr.address = terms[0];
          addr.prefixLength = parseInt(terms[1], 10);
          return true;
        }

        if (RE_UNIX_IPV6_ADDR.test(term.trim())) {
          addr.address = terms[i + 1].split(/\%/)[0];
        }

        if (RE_UNIX_IPV6_PREFIX_LENGTH.test(term)) {
          addr.prefixLength = parseInt(terms[i + 1], 10);
          return true;
        }

        return false;
      });
    } // look for status


    if (RE_STATUS.test(line)) {
      debug('status information found for interface %s (%s)', iface.name, line);
      terms = line.split(/\:/g);
      iface.active = RE_UNIX_STATUS_ACTIVE.test(terms[1]) || RE_NUMBER.test(terms[1]);
    }
  }); // populate the internal interfaces array

  hardwareInterfaces.forEach(function (iface) {
    var include = // filter out internal interfaces as applicable
    (networkInfo.options.internal || !iface.internal) && ( // filter out non-active interfaces as applicable
    !networkInfo.options.active || iface.active);

    if (include) {
      result.push(iface);
    }
  }); // sort by metric / priority

  result.sort(function (a, b) {
    return (a.metric || a.index || DEFAULT_METRIC) - (b.metric || b.index || DEFAULT_METRIC);
  });
  return result;
}

var NetworkInfo = /*#__PURE__*/function () {
  function NetworkInfo(options) {
    (0, _classCallCheck2["default"])(this, NetworkInfo);
    debug('new NetworkInfo(%o)', options);
    this._options = options || {};

    _ensureDefaultOptions(this);
  }

  (0, _createClass2["default"])(NetworkInfo, [{
    key: "applySettings",
    value: function () {
      var _applySettings = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(name, settings) {
        var iface, result, addr, args;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_isNullOrUndefined(name)) {
                  _context.next = 2;
                  break;
                }

                throw new Error('interface name is required');

              case 2:
                if (!_isNullOrUndefined(settings)) {
                  _context.next = 4;
                  break;
                }

                throw new Error('settings are required');

              case 4:
                _context.next = 6;
                return _ifconfig(this, name);

              case 6:
                iface = _context.sent;

                if (_isNullOrUndefined(settings.active)) {
                  _context.next = 19;
                  break;
                }

                debug('attempt %sabling interface %s', settings.active ? 'en' : 'dis', name);

                if (!settings.active) {
                  _context.next = 15;
                  break;
                }

                _context.next = 12;
                return _ifconfig(this, name, DEFAULT_ACTIVE_UP);

              case 12:
                result = _context.sent;
                _context.next = 18;
                break;

              case 15:
                _context.next = 17;
                return _ifconfig(this, name, DEFAULT_ACTIVE_DOWN);

              case 17:
                result = _context.sent;

              case 18:
                debug('result of %sabling %s: %o', settings.active ? 'en' : 'dis', name, result);

              case 19:
                if (_isNullOrUndefined(settings.hardwareAddress)) {
                  _context.next = 25;
                  break;
                }

                debug('attempt setting hardware address for interface %s', name);
                _context.next = 23;
                return _ifconfig(this, name, 'hw', 'ether', settings.hardwareAddress);

              case 23:
                result = _context.sent;
                debug('result of setting hardware address for interface %s: %o', name, result);

              case 25:
                if (_isNullOrUndefined(settings.ipv4)) {
                  _context.next = 36;
                  break;
                }

                addr = settings.ipv4, args = [name]; // if an array, select the first object

                if (Array.isArray(addr)) {
                  addr = addr[0];
                }

                if (!_isNullOrUndefined(addr.address)) {
                  debug('applying ipv4 hardware address: %s', addr.address);
                  args.push(addr.address);
                }

                if (!_isNullOrUndefined(addr.broadcast)) {
                  debug('applying ipv4 hardware broadcast: %s', addr.broadcast);
                  args.push('broadcast', addr.broadcast);
                }

                if (!_isNullOrUndefined(addr.netmask)) {
                  debug('applying ipv4 hardware netmask: %s', addr.netmask);
                  args.push('netmask', addr.netmask);
                }

                if (!(args.length > 1)) {
                  _context.next = 36;
                  break;
                }

                _context.next = 34;
                return _ifconfig.apply(void 0, [this].concat(args));

              case 34:
                result = _context.sent;
                debug('result of ipv4 settings update to %s: %o', name, result);

              case 36:
                if (_isNullOrUndefined(settings.mtu)) {
                  _context.next = 42;
                  break;
                }

                debug('attempt setting mtu for interface %s', name);
                _context.next = 40;
                return _ifconfig(this, name, 'mtu', settings.mtu);

              case 40:
                result = _context.sent;
                debug('result of setting mtu for interface %s: %o', name, result);

              case 42:
                _context.next = 44;
                return _ifconfig(this, name);

              case 44:
                iface = _context.sent;
                return _context.abrupt("return", _parseInterfaceInfo(this, iface)[0]);

              case 46:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function applySettings(_x, _x2) {
        return _applySettings.apply(this, arguments);
      }

      return applySettings;
    }()
  }, {
    key: "listInterfaces",
    value: function () {
      var _listInterfaces = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var result;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.options.verbose) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 3;
                return _ifconfig(this, VERBOSE);

              case 3:
                _context2.t0 = _context2.sent;
                _context2.next = 9;
                break;

              case 6:
                _context2.next = 8;
                return _ifconfig(this);

              case 8:
                _context2.t0 = _context2.sent;

              case 9:
                result = _context2.t0;
                return _context2.abrupt("return", _parseInterfaceInfo(this, result));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function listInterfaces() {
        return _listInterfaces.apply(this, arguments);
      }

      return listInterfaces;
    }()
  }, {
    key: "options",
    get: function get() {
      return this._options;
    }
  }]);
  return NetworkInfo;
}();

exports.NetworkInfo = NetworkInfo;
var _default = {
  NetworkInfo: NetworkInfo
};
exports["default"] = _default;
//# sourceMappingURL=index.js.map
