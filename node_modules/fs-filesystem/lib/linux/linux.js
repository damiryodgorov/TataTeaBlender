'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLinux = exports.parsedfT = exports.splitdfTLine = exports.parsefdiskl = exports.parsefdisklVolumeData = exports.parsefdisklDeviceData = exports.parselsblk = exports.parselsblkVolumeData = exports.parselsblkDeviceData = exports.mergeVolumesAndDevicesLinux = exports.createNewVolume = exports.createNewDevice = exports.getNodeId = exports.COMMAND = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _functional = require('../functional');

var _functional2 = _interopRequireDefault(_functional);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var constant = _functional2.default.constant,
    ifElse = _functional2.default.ifElse,
    each = _functional2.default.each;
var _F$R = _functional2.default.R,
    compose = _F$R.compose,
    map = _F$R.map,
    reduce = _F$R.reduce,
    filter = _F$R.filter;
var COMMAND = exports.COMMAND = 'df -T && ' + 'echo "" && echo "**********" && echo "" && ' + 'fdisk -l && ' + 'echo "" && echo "**********" && echo "" && ' + 'lsblk -o kname,fstype,mountpoint,label,ro,rm,model,type -P';

var getNodeId = exports.getNodeId = function getNodeId(node) {
  return (0, _utilities.lasti)(node.split('/').filter(function (s) {
    return s.trim();
  }));
};

var createNewDevice = exports.createNewDevice = function createNewDevice(emptyDevice) {
  return function (id) {
    var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var device = emptyDevice();
    device.id = id;
    device.node = node || '/dev/' + id;
    device.name = id;
    device.whole = true;
    device.parent = id;
    return device;
  };
};

var createNewVolume = exports.createNewVolume = function createNewVolume(emptyVolume) {
  return function (id) {
    var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var volume = emptyVolume();
    volume.id = id;
    volume.node = node || '/dev/' + id;
    volume.name = id;
    volume.parent = id.match(/[a-z]+/)[0];
    return volume;
  };
};

var mergeVolumesAndDevicesLinux = exports.mergeVolumesAndDevicesLinux = function mergeVolumesAndDevicesLinux(emptyDevice) {
  return function (_ref) {
    var devices = _ref.devices,
        volumes = _ref.volumes;

    var vkeys = Object.keys(volumes);
    // Merge volumes to devices
    each(function (dev, key) {
      dev.volumes = map(compose(function (volume) {
        if (dev.volumeBlockSize) volume.blockSize = dev.volumeBlockSize;
        return volume;
      }, function (k) {
        return volumes[k];
      }), filter(function (k) {
        return (0, _utilities.hasSubstr)(k, key);
      }, vkeys) // volume keys that belong to current device
      );
    }, devices);
    // Remove the volumeBlockSize property from the devices
    return {
      devices: map(function (d) {
        return reduce(function (a, v, k) {
          if (k !== 'volumeBlockSize') a[k] = v;
          return a;
        }, emptyDevice())(d);
      }, devices)
    };
  };
};

// Values Example
// ['sdc1', 'vfat', '/media/user/KINGSTON', 'KINGSTON', '0', '1', '', 'part']
/*
 * 0: KNAME
 * 1: FSTYPE
 * 2: MOUNTPOINT
 * 3: LABEL
 * 4: RO
 * 5: RM
 * 6: MODEL
 * 7: TYPE
 */
var parselsblkDeviceData = exports.parselsblkDeviceData = function parselsblkDeviceData(createNewDevice) {
  return function (acc) {
    return function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 8),
          id = _ref3[0],
          fs = _ref3[1],
          mountPoint = _ref3[2],
          label = _ref3[3],
          readOnly = _ref3[4],
          removable = _ref3[5],
          model = _ref3[6],
          _ = _ref3[7];

      if (!acc.devices[id]) {
        acc.devices[id] = createNewDevice(id);
      }
      acc.devices[id].readOnly = !!parseInt(readOnly);
      acc.devices[id].removable = !!parseInt(removable);
      acc.devices[id].description = acc.devices[id].description || label || null;
      return acc;
    };
  };
};

var parselsblkVolumeData = exports.parselsblkVolumeData = function parselsblkVolumeData(createNewVolume) {
  return function (acc) {
    return function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 8),
          id = _ref5[0],
          fs = _ref5[1],
          mountPoint = _ref5[2],
          label = _ref5[3],
          readOnly = _ref5[4],
          removable = _ref5[5],
          model = _ref5[6],
          _ = _ref5[7];

      if (!acc.volumes[id]) {
        acc.volumes[id] = createNewVolume(id);
      }
      acc.volumes[id].fs = fs || null;
      acc.volumes[id].mounted = !!mountPoint;
      acc.volumes[id].mountPoint = mountPoint || null;
      acc.volumes[id].readOnly = !!parseInt(readOnly);
      acc.volumes[id].removable = !!parseInt(removable);
      acc.volumes[id].description = acc.volumes[id].description || label || null;
      return acc;
    };
  };
};

var parselsblk = exports.parselsblk = function parselsblk(parselsblkDeviceData, parselsblkVolumeData) {
  return function (lsblk) {
    return function (acc) {
      return compose(constant(acc), each(compose(ifElse(function (values) {
        return values[values.length - 1] === 'disk';
      }, parselsblkDeviceData(acc), parselsblkVolumeData(acc)), function (line) {
        return map(function (field) {
          return field.replace(/"/g, '').split('=')[1];
        }, line.match(/([A-Z]+="[^"]*")+/g));
      })), filter(function (s) {
        return s.trim();
      }), // remove empty lines
      // remove empty lines & tmp file systems
      _utilities.splitEOL)(lsblk);
    };
  };
};

var parsefdisklDeviceData = exports.parsefdisklDeviceData = function parsefdisklDeviceData(getNodeId, createNewDevice) {
  return function (acc) {
    return function (_ref6) {
      var _ref7 = _toArray(_ref6),
          head = _ref7[0],
          tail = _ref7.slice(1);

      var _head$match$slice = head.match(/Disk\s(.*):\s.*,\s(\d+)\sbytes,\s(\d+) sectors/).slice(1),
          _head$match$slice2 = _slicedToArray(_head$match$slice, 3),
          node = _head$match$slice2[0],
          size = _head$match$slice2[1],
          blocks = _head$match$slice2[2];

      var id = getNodeId(node);
      if (!acc.devices[id]) {
        acc.devices[id] = createNewDevice(id, node);
      }
      acc.devices[id].blocks = parseInt(blocks);
      acc.devices[id].size = parseInt(size);
      each(ifElse(function (line) {
        return line.match(/Sector.*:\s\d+\sbytes/);
      }, function (line) {
        var _line$match$slice = line.match(/(\d+)\s.*\s(\d+)\s/).slice(1),
            _line$match$slice2 = _slicedToArray(_line$match$slice, 2),
            logical = _line$match$slice2[0],
            physical = _line$match$slice2[1];

        acc.devices[id].blockSize = parseInt(physical);
        acc.devices[id].volumeBlockSize = parseInt(logical);
      }, function () {}), tail);
      return acc;
    };
  };
};

var parsefdisklVolumeData = exports.parsefdisklVolumeData = function parsefdisklVolumeData(getNodeId, createNewVolume) {
  return function (acc) {
    return reduce(function (acc, l) {
      return compose(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 3),
            node = _ref9[0],
            sectors = _ref9[1],
            description = _ref9[2];

        var id = getNodeId(node);
        if (!acc.volumes[id]) {
          acc.volumes[id] = createNewVolume(id, node);
        }
        acc.volumes[id].blocks = parseInt(sectors);
        acc.volumes[id].description = description;
        return acc;
      }, function (l) {
        return l.match(/([\w\\/]+)\s+.*\s(\d+)\s+[\w.]+\s(.*)/).slice(1);
      })(l);
    }, acc);
  };
};

var parsefdiskl = exports.parsefdiskl = function parsefdiskl(parsefdisklDeviceData, parsefdisklVolumeData) {
  return function (fdiskl) {
    return function (acc) {
      return compose(function (blocks) {
        return blocks.reduce(function (a, block, i) {
          return ifElse(function () {
            return (i + 1) % 2;
          }, function () {
            return compose(parsefdisklDeviceData(a), function (arr) {
              return arr.filter(function (s) {
                return s.trim();
              });
            }, _utilities.splitEOL)(block);
          }, function () {
            return compose(parsefdisklVolumeData(a), function (arr) {
              return arr.filter(function (s) {
                return s.trim();
              });
            }, function (arr) {
              return arr.splice(1);
            }, _utilities.splitEOL)(block);
          })();
        }, acc);
      }, filter(function (s) {
        return s.trim();
      }), // remove empty lines
      (0, _utilities.splitEOL)(2) // split into disk and volumes
      )(fdiskl);
    };
  };
};

// split by space, except if space is preceeded by \ (paths with spaces)
// This is used instead of a negative lookbehind (`(?<!\\)\s+`)
var splitdfTLine = exports.splitdfTLine = function splitdfTLine(line) {
  return line.split(/\s+/).filter(function (s) {
    return s.trim();
  }).reduce(function (a, field) {
    if ((0, _utilities.lasti)(a) && (0, _utilities.lasti)((0, _utilities.lasti)(a)) === '\\') a[a.length - 1] += ' ' + field;else a.push(field);
    return a;
  }, []);
};

var parsedfT = exports.parsedfT = function parsedfT(getNodeId, createNewVolume, splitdfTLine) {
  return function (dft) {
    return function (acc) {
      return compose(reduce(function (acc, line) {
        return compose(function (_ref10) {
          var _ref11 = _slicedToArray(_ref10, 7),
              node = _ref11[0],
              filesystem = _ref11[1],
              size = _ref11[2],
              used = _ref11[3],
              available = _ref11[4],
              _ = _ref11[5],
              mountPoint = _ref11[6];

          var id = getNodeId(node);
          acc.volumes[id] = createNewVolume(id, node);
          acc.volumes[id].mounted = true;
          acc.volumes[id].mountPoint = mountPoint;
          acc.volumes[id].fs = filesystem === 'vfat' ? 'FAT32' : filesystem;
          acc.volumes[id].space.total = parseInt(size) * 1024;
          acc.volumes[id].space.available = parseInt(available) * 1024;
          acc.volumes[id].space.used = parseInt(used) * 1024;
          return acc;
        }, splitdfTLine)(line);
      }, acc), function (a) {
        return a.slice(1);
      }, // remove table header
      filter(function (s) {
        return s.trim() && !(0, _utilities.hasSubstr)(s, 'tmpfs');
      }), _utilities.splitEOL)(dft);
    };
  };
};

var parseLinux = exports.parseLinux = function parseLinux(mergeVolumesAndDevicesLinux, parselsblk, parsefdiskl, parsedfT) {
  return function (userFilter) {
    return function (output) {
      return compose(function (_ref12) {
        var devices = _ref12.devices;
        return {
          devices: filter(userFilter, devices)
        };
      }, function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 3),
            dft = _ref14[0],
            fdiskl = _ref14[1],
            lsblk = _ref14[2];

        return compose(mergeVolumesAndDevicesLinux, parselsblk(lsblk), parsefdiskl(fdiskl), parsedfT(dft))({ devices: {}, volumes: {} });
      }, function (s) {
        return s.split(/\n\*+\n\n/);
      } // Split utilities
      )(output);
    };
  };
};