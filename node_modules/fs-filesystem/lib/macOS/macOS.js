'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMacOS = exports.parseMacOSToProps = exports.parseNodeId = exports.addEmptyNode = exports.addEmptyVolumeToDevice = exports.addEmptyDevice = exports.getPropsTarget = exports.nodeType = exports.macOSFS = exports.getMacOSBytes = exports.COMMAND = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _functional = require('../functional');

var _functional2 = _interopRequireDefault(_functional);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var identity = _functional2.default.identity,
    cond = _functional2.default.cond,
    each = _functional2.default.each,
    tap = _functional2.default.tap,
    tautology = _functional2.default.tautology;
var _F$R = _functional2.default.R,
    compose = _F$R.compose,
    map = _F$R.map,
    reduce = _F$R.reduce,
    filter = _F$R.filter;
var COMMAND = exports.COMMAND = 'diskutil info -all';

var getMacOSBytes = exports.getMacOSBytes = function getMacOSBytes(str) {
  return parseInt(str.match(/\((\d+) Bytes\)/)[1]);
};

var macOSFS = exports.macOSFS = function macOSFS(fs) {
  switch (fs) {
    case 'ExFAT':
      return 'ExFAT';
    case 'MS-DOS':
      return 'FAT';
    case 'MS-DOS FAT12':
      return 'FAT12';
    case 'MS-DOS FAT16':
      return 'FAT16';
    case 'MS-DOS FAT32':
    case 'fat32':
      return 'FAT32';
    case 'HFS+':
    case 'Case-sensitive HFS+':
    case 'hfsx':
    case 'Case-sensitive Journaled HFS+':
    case 'jhfsx':
    case 'Journaled HFS+':
    case 'jhfs+':
      return 'HFS+';
    case 'Free Space':
    case 'free':
    default:
      return null;
  }
};

/* lower order functions for parseMacOS */

// Tells you whether this is a volume or a device
var nodeType = exports.nodeType = function nodeType(node) {
  return node.space ? 'volume' : 'device';
};

// Gets target device / volume for parseMacOSToProps
var getPropsTarget = exports.getPropsTarget = function getPropsTarget(acc) {
  return function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        devid = _ref2[0],
        id = _ref2[1];

    return id ? acc.devices[devid].volumes[id] : acc.devices[devid];
  };
};

// Adds an empty device to accumulator
var addEmptyDevice = exports.addEmptyDevice = function addEmptyDevice(acc) {
  return function (id) {
    acc.devices[id] = (0, _utilities.emptyDevice)();
  };
};

// Adds an empty volume to its parent device
var addEmptyVolumeToDevice = exports.addEmptyVolumeToDevice = function addEmptyVolumeToDevice(device) {
  return function (id) {
    device.volumes = device.volumes ? device.volumes : {};
    device.volumes[id] = (0, _utilities.emptyVolume)();
  };
};

// Adds an empty device / volume based off wether a volume id is provided
var addEmptyNode = exports.addEmptyNode = function addEmptyNode(addEmptyDevice, addEmptyVolumeToDevice) {
  return function (acc) {
    return function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          devid = _ref4[0],
          id = _ref4[1];

      return id ? addEmptyVolumeToDevice(acc.devices[devid])(id) : addEmptyDevice(acc)(devid);
    };
  };
};

// Finds the device id as well as the volume id (where applicable) from the provided input lines
var parseNodeId = exports.parseNodeId = function parseNodeId(acc) {
  return function (lines) {
    return compose(function (id) {
      var devid = Object.keys(acc.devices).find(function (dev) {
        return id.match('^' + dev);
      });
      return devid ? [devid, id] : [id, void 0];
    }, function (lines) {
      return lines.find(function (l) {
        return l.match('Device Identifier');
      }).match(/:\s+(.*)/)[1];
    })(lines);
  };
};

// Maps received line to a property on the node
var parseMacOSToProps = exports.parseMacOSToProps = function parseMacOSToProps(macOSFS, getMacOSBytes) {
  var PROPERTY_MAP = {
    'Device Identifier': {
      target: 'dual',
      key: 'id',
      mapper: function mapper(node, value) {
        node.id = value;
      }
    },
    'Device Node': {
      target: 'dual',
      key: 'node',
      mapper: function mapper(node, value) {
        node.node = value;
      }
    },
    'Whole': {
      target: 'dual',
      key: 'whole',
      mapper: function mapper(node, value) {
        node.whole = (0, _utilities.getYesNo)(value);
      }
    },
    'Part of Whole': {
      target: 'dual',
      key: 'parent',
      mapper: function mapper(node, value) {
        node.parent = value;
      }
    },
    'Device / Media Name': {
      target: 'dual',
      key: 'description',
      mapper: function mapper(node, value) {
        node.description = value;
      }
    },
    'Volume Name': {
      target: 'dual',
      key: 'name',
      mapper: function mapper(node, value) {
        node.name = (0, _utilities.hasSubstr)(value, 'Not applicable') ? null : value;
      }
    },
    'Mounted': {
      target: 'dual',
      key: 'mounted',
      mapper: function mapper(node, value) {
        node.mounted = !(0, _utilities.hasSubstr)(value, 'Not applicable');
      }
    },
    'Mount Point': {
      target: 'dual',
      key: 'mountPoint',
      mapper: function mapper(node, value) {
        node.mountPoint = (0, _utilities.hasSubstr)(value, 'Not applicable') ? null : value;
      }
    },
    'File System Personality': {
      target: 'volume',
      key: 'fs',
      mapper: function mapper(node, value) {
        node.fs = macOSFS(value);
      }
    },
    'Partition Type': {
      target: 'volume',
      key: 'partitionType',
      mapper: function mapper(node, value) {
        node.partitionType = value;
      }
    },
    'Protocol': {
      target: 'device',
      key: 'protocol',
      mapper: function mapper(node, value) {
        node.protocol = value;
      }
    },
    'Disk Size': {
      target: 'device',
      key: 'size',
      mapper: function mapper(node, value) {
        node.size = getMacOSBytes(value);
      }
    },
    'Total Size': {
      target: 'device',
      key: 'size',
      mapper: function mapper(node, value) {
        node.size = node.size || getMacOSBytes(value);
      }
    },
    'Device Block Size': {
      target: 'device',
      key: 'blockSize',
      mapper: function mapper(node, value) {
        node.blockSize = parseInt(value.match(/\d+/)[0]);
      }
    },
    'Volume Total Space': {
      target: 'volume',
      key: 'space.total',
      mapper: function mapper(node, value) {
        node.space.total = getMacOSBytes(value);
      }
    },
    'Volume Used Space': {
      target: 'volume',
      key: 'space.used',
      mapper: function mapper(node, value) {
        node.space.used = getMacOSBytes(value);
      }
    },
    'Volume Available Space': {
      target: 'volume',
      key: 'space.available',
      mapper: function mapper(node, value) {
        node.space.available = getMacOSBytes(value);
        if (node.space.total !== null && node.space.used === null) {
          node.space.used = node.space.total - node.space.available;
        }
      }
    },
    'Allocation Block Size': {
      target: 'volume',
      key: 'blockSize',
      mapper: function mapper(node, value) {
        node.blockSize = parseInt(value.match(/\d+/)[0]);
      }
    },
    'Read-Only Media': {
      target: 'device',
      key: 'readOnly',
      mapper: function mapper(node, value) {
        node.readOnly = (0, _utilities.getYesNo)(value);
      }
    },
    'Read-Only Volume': {
      target: 'dual',
      key: 'readOnly',
      mapper: function mapper(node, value) {
        node.readOnly = (0, _utilities.hasSubstr)(value, 'Not applicable (not mounted)') ? null : (0, _utilities.getYesNo)(value);
      }
    },
    'Removable Media': {
      target: 'device',
      key: 'removable',
      mapper: function mapper(node, value) {
        node.removable = value === 'Fixed';
      }
    }
  };

  return function (node, key, value) {
    return cond({
      // Property ought to be mapped on current node
      c: function c(_ref5) {
        var node = _ref5.node,
            key = _ref5.key;
        return PROPERTY_MAP[key] && PROPERTY_MAP[key].target === nodeType(node);
      },
      a: function a(_ref6) {
        var node = _ref6.node,
            key = _ref6.key,
            value = _ref6.value;

        if (PROPERTY_MAP[key]) PROPERTY_MAP[key].mapper(node, value);
        return node;
      }
    }, {
      // Property ought to be mapped on both device and volume
      c: function c(_ref7) {
        var node = _ref7.node,
            key = _ref7.key;
        return PROPERTY_MAP[key] && PROPERTY_MAP[key].target === 'dual';
      },
      a: function a(_ref8) {
        var node = _ref8.node,
            key = _ref8.key,
            value = _ref8.value;

        if (PROPERTY_MAP[key]) {
          PROPERTY_MAP[key].mapper(node, value);
          if (node.volumes && node.volumes[node.id]) {
            PROPERTY_MAP[key].mapper(node.volumes[node.id], value);
          }
        }
        return node;
      }
    }, {
      // Property ought to be mapped on volume but current node is a device => dual
      c: function c(_ref9) {
        var node = _ref9.node,
            key = _ref9.key;
        return PROPERTY_MAP[key] && PROPERTY_MAP[key].target === 'volume' && nodeType(node) === 'device';
      },
      a: function a(_ref10) {
        var node = _ref10.node,
            key = _ref10.key,
            value = _ref10.value;

        if (!(node.volumes && node.volumes[node.id])) {
          addEmptyVolumeToDevice(node)(node.id);
          each(function (_ref11) {
            var target = _ref11.target,
                key = _ref11.key;
            if (target === 'dual') node.volumes[node.id][key] = node[key];
          }, PROPERTY_MAP);
        }
        PROPERTY_MAP[key].mapper(node.volumes[node.id], value);
        return node;
      }
    }, {
      // Property ought to be mapped on device but current node is a volume
      // or property is not in PROPERTY_MAP
      c: tautology,
      a: function a(_ref12) {
        var node = _ref12.node,
            key = _ref12.key,
            value = _ref12.value;
        return node;
      }
    })({ node: node, key: key, value: value });
  };
};

// Parses output of COMMAND to an object
var parseMacOS = exports.parseMacOS = function parseMacOS(getPropsTarget, addEmptyNode, parseNodeId, parseMacOSToProps) {
  return function (userFilter) {
    return function (output) {
      return compose(
      // Filter devices according to userFilter
      function (_ref13) {
        var devices = _ref13.devices;
        return {
          devices: filter(userFilter, devices)
        };
      },
      // Map devices[devid].volumes object to an array of volumes (to standardize with other OSes)
      function (acc) {
        acc.devices = each(function (dev, k) {
          dev.volumes = dev.volumes ? Object.keys(dev.volumes).map(function (k) {
            return dev.volumes[k];
          }) : [];
        }, acc.devices);
        return acc;
      },
      // reduce input entries to device / volume objects and return accumulator
      reduce(function (acc, entry) {
        return compose(_functional2.default.K(acc), _functional2.default.S(_functional2.default.C(reduce(function (target, line) {
          return parseMacOSToProps.apply(undefined, [target].concat(_toConsumableArray(line.split(/:\s+/))));
        })), compose(getPropsTarget(acc), tap(addEmptyNode(acc)), parseNodeId(acc))), filter(identity), map(function (s) {
          return s.trim();
        }), function (s) {
          return s.split('\n');
        })(entry);
      }, { devices: {} }), filter(function (s) {
        return s.trim();
      }), function (s) {
        return s.split(/\*{10}/);
      } // Split per entry
      )(output);
    };
  };
};