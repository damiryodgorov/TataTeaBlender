'use strict';

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compose = _ramda2.default.compose,
    composeP = _ramda2.default.composeP,
    map = _ramda2.default.map,
    mapAccum = _ramda2.default.mapAccum;

// I :: a -> a

var I = function I(x) {
  return x;
};

// K :: a -> b -> a
var K = function K(x) {
  return function (y) {
    return x;
  };
};

// C :: (b -> (a -> *)), a, b -> *
var C = function C(f) {
  return function (a) {
    return function (b) {
      return f(b)(a);
    };
  };
};

// S :: (x -> y -> *), (x -> y) -> *
// S :: (x -> y -> *) -> (x -> y) -> *
var S = function S(f, g) {
  return g ? function (x) {
    return f(x)(g(x));
  } : function (g) {
    return function (x) {
      return f(x)(g(x));
    };
  };
};

// each :: (a -> *), [a]|Object -> undefined
var each = function each(f, x) {
  return x ? !Array.isArray(x) ? _ramda2.default.forEachObjIndexed(f, x) : _ramda2.default.forEach(f, x) : function (x) {
    return !Array.isArray(x) ? _ramda2.default.forEachObjIndexed(f, x) : _ramda2.default.forEach(f, x);
  };
};

// reductor :: ((a, b, x) -> a), a, x -> a
var reductor = function reductor(f, a, x) {
  if (Array.isArray(x)) {
    return x.reduce(f, a);
  } else {
    var acc = a;
    for (var k in x) {
      acc = f(acc, x[k], k, x);
    }
    return acc;
  }
};

// reduce :: ((a, b, x) -> a) -> a -> x -> a
// reduce :: ((a, b, x) -> a), a -> x -> a
// reduce :: ((a, b, x) -> a), a, x -> a
var reduce = function reduce(f, a, x) {
  return x ? reductor(f, a, x) : a ? function (x) {
    return reductor(f, a, x);
  } : function (a, x) {
    return x ? reductor(f, a, x) : function (x) {
      return reductor(f, a, x);
    };
  };
};

// filter :: Object -> Object
var filterObjIndexed = function filterObjIndexed(f, x) {
  return compose(_ramda2.default.reduce(function (acc, k) {
    acc[k] = x[k];return acc;
  }, {}), _ramda2.default.filter(function (k) {
    return f(x[k], k, x);
  }), _ramda2.default.keys)(x);
};

// filter :: Object|[a] -> Object|[a]
var filter = function filter(f, x) {
  return x ? !Array.isArray(x) ? filterObjIndexed(f, x) : _ramda2.default.filter(f, x) : function (x) {
    return !Array.isArray(x) ? filterObjIndexed(f, x) : _ramda2.default.filter(f, x);
  };
};

// ifElse :: (a -> Bool), (a -> *), (a -> *) -> (a -> *)
var ifElse = function ifElse(f, g, h) {
  return function (x) {
    return f(x) ? g(x) : h(x);
  };
};

// condr :: x, Integer, [{ c: (x -> Bool), a: (x -> *)}] -> *|x
var condr = function condr(x, i, cs) {
  return i < cs.length ? cs[i].c(x) ? cs[i].a(x) : condr(x, i + 1, cs) : x;
};

// cond :: [{ c: (x -> Bool), a: (x -> *)}] -> x -> *
var cond = function cond() {
  for (var _len = arguments.length, cases = Array(_len), _key = 0; _key < _len; _key++) {
    cases[_key] = arguments[_key];
  }

  return function (x) {
    return ifElse(function (cs) {
      return cs.length;
    }, function (cs) {
      return condr(x, 0, cs);
    }, function () {
      return I(x);
    })(cases);
  };
};

// tap :: Function -> a -> a
var tap = function tap(f) {
  return function (x) {
    f(x);
    return x;
  };
};

// eqeqeq :: * -> * -> Bool
var eqeqeq = function eqeqeq(x) {
  return function (y) {
    return x === y;
  };
};

// tautology :: * -> Bool
var tautology = function tautology() {
  return true;
};

// thrower :: string, Error|undefined -> undefined
var thrower = function thrower(msg) {
  var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;
  throw new Type(msg);
};

module.exports = {
  I: I,
  K: K,
  C: C,
  S: S,
  each: each,
  filter: filter,
  ifElse: ifElse,
  cond: cond,
  tap: tap,
  eqeqeq: eqeqeq,
  tautology: tautology,
  thrower: thrower,
  identity: I,
  constant: K,
  flip: C,
  split: S,
  substitute: S,
  R: {
    compose: compose,
    composeP: composeP,
    map: map,
    mapAccum: mapAccum,
    reduce: reduce,
    each: each,
    filter: filter
  }
};