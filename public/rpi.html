<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FTI Touch Display</title>
   
    <link rel="stylesheet" href="css/base.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="stylesheet" type="text/css" href="css/keyboard.min.css"/>
    <link rel="stylesheet" type="text/css" href="css/jquery-ui.min.css"/>
 <!-- <script src="scripts/browser.min.js"></script>-->
   <script src="scripts/jquery.min.js"></script>
   <script src="scripts/jquery-ui.min.js"></script>
  <!--  <script src="scripts/jquery.keyboard.min.js"></script>
     <script src="scripts/smoothie.js"></script>-->

<!--<script src="scripts/react.min.js"></script>-->
<!--<script type="text/javascript" src="scripts/concrete.min.js"></script>-->
  <!--<script type="text/javascript" src="node_modules/react/dist/react.js"></script>
    <script type="text/javascript" src="node_modules/react-dom/dist/react-dom.min.js"></script>-->
   <script type="text/javascript" src="scripts/socket.io.min.js"></script>
  </head>
  <body>
    <div id="content"></div>
    <script>

let vdefList ={};
let vdefByIp = {};
var _Vdef;
var _pVdef;
let isVdefSet = false;
var ftiTouch = true //this.
var _nVdf;
const value_groups = {
  "Calibration"  : ["AutoPhasePacks", "CalibrateMode", "PhaseTrigLimit", "PhaseTrigThres","PhaseLimitDry","PhaseLimitDrySpread",
                  "PhaseAngle", "PhaseLimitWet","PhaseLimitWetSpread","MPhaseOrder","MPhaseDD","MPhaseRD","PhaseSpeed",
                  "OscPower","PhaseMode","PhaseModeHold","AutoLearn"],
  "Faults"       : ["FaultStore","Mask", "FaultLatch", "FaultRejMode", "FlashRejCount", "Rej2Fault", "TOGGLE_REJ_MODE","FaultClearTime"], 
  "Output"       : ["BannerBuzzMode", "BannerMode", "BannerRejMode","IOBoardType","LightStackMode"],
  "Password"     : ["PassAccCal", "PassAccClrFaults", "PassAccClrLatch", "PassAccClrRej", "PassAccProd", "PassAccSelUnit", 
                      "PassAccSens", "PassAccTest", "PassOn", "PW1", "PW2", "PW3", "PW4","PassAccTime","PassAccSync"],
  "Rej Setup"    : ["AppUnitDist", "BeltSpeed",  "EyeBlockTime", "EyeDetSwipe", "EyeDist", "EyeMinGapDist", "EyePkgLength", 
                      "EyeReject", "HeadCoilSp", "HeadDepth", "Rej2Check", "Rej2Latch", "RejBinDoorTime", "RejCheckMode",
                      "RejCheckTime", "RejDelClock", "RejDelSec", "RejDelSec2", "RejDurSec", "RejDurSec2", "RejExitDist",
                        "RejExitWin", "RejLatchMode", "RejMode", "RejOnProdHi", "RejTravDel", "RejTravDur", "SplitPkgLength",
                        "PowerupRej","ExcessRejects","ExcessRejTime"],
  "Sensitivity" : ["PeakMode","Sens","BigMetThres","DetMode","ThresX","ThresR","DetThresh","ThresProdHi","FilterNoise","DcCoeffNorm"],
  "Test"        : ["HaloBoard","HaloPeakRFe", "HaloPeakRNFe", "HaloPeakRSs", "HaloPeakXFe", "HaloPeakXNFe", "HaloPeakXSs", 
                    "IBTestPassesFe", "IBTestPassesNFe", "IBTestPassesSS", "TestMode", "TestTime","TestDeferTime"],
  "Input"       : ["CIPCycleTime","CIPDwellTime"]                      
}  

const _testMap = [[{count:'TestConfigCount0_0',metal:'TestConfigMetal0_0'},{count:'TestConfigCount0_1',metal:'TestConfigMetal0_1'},{count:'TestConfigCount0_2',metal:'TestConfigMetal0_2'}],
                  [{count:'TestConfigCount1_0',metal:'TestConfigMetal1_0'},{count:'TestConfigCount1_1',metal:'TestConfigMetal1_1'},{count:'TestConfigCount1_2',metal:'TestConfigMetal1_2'}],
                  [{count:'TestConfigCount2_0',metal:'TestConfigMetal2_0'},{count:'TestConfigCount2_1',metal:'TestConfigMetal2_1'},{count:'TestConfigCount2_2',metal:'TestConfigMetal2_2'}],
                  [{count:'TestConfigCount3_0',metal:'TestConfigMetal3_0'},{count:'TestConfigCount3_1',metal:'TestConfigMetal3_1'},{count:'TestConfigCount3_2',metal:'TestConfigMetal3_2'}]]
const _testSettingsMap = [{ack:'TestConfigAck0',op:'TestConfigOperater0',haloMode:'TestConfigHaloMode0'},
                          {ack:'TestConfigAck1',op:'TestConfigOperater1',haloMode:'TestConfigHaloMode1'},
                          {ack:'TestConfigAck2',op:'TestConfigOperater2',haloMode:'TestConfigHaloMode2'},
                          {ack:'TestConfigAck3',op:'TestConfigOperater3',haloMode:'TestConfigHaloMode3'}]
      function load_vdef_parameters(json) {
  // body...
  if (vdefList[json['@version']]){
    console.log('already have this version')

  }else{
      Vdef = json;
  console.log(json)
  var res = [];
    res[0] = [];
    res[1] = [];
    res[2] = [];
    res[3] = [];
    nVdf = {};
    nVdf['Other'] = [];
    nVdf['Password'] = [];
    nVdf['Rej Setup'] = [];
    nVdf['Faults'] = [];
    nVdf['Output'] = [];
    nVdf['Sensitivity'] = [];
    nVdf['Test'] = [];
    nVdf['Calibration'] = [];

    json["@params"].forEach(function(p ){
      res[p["@rec"]][p["@name"]] = p;
     var nm = p['@name'];
     var otherFlag = true;
     for(var o in value_groups){
     // console.log(o)
     if(o == 'Faults'){
      if(nm.indexOf('FaultMask')!=1){
        nVdf[o].push(p);
        otherFlag = false;
        break;
      }
     }else if(o == 'Test'){
      if(nm.indexOf('TestConfig')!= -1){
        nVdf[o].push(p);
        otherFlag = false;
        break;
      }
     }
     if(value_groups[o].indexOf(nm) != -1){
      nVdf[o].push(p);
      otherFlag = false;
      break;
     }
   }
   if(otherFlag){  
      nVdf['Other'].push(p)
   }
    });
    console.log(nVdf)
    res[2] = json["@deps"];
    res[3] = json["@labels"]
    pVdef = res;
    vdefList[json['@version']] = [json, res, nVdf]
    isVdefSet = true;
    

  }

  //isVdefSet = true;
}
class Params{
  static frac_value(int){
    return (int/(1<<15))
  }
  static mm(dist, metric){
    if(metric==0){
      return (dist/25.4).toFixed(1) + " in"

    }
    else{
      return dist + " mm";
    }

  }
  static prod_name_u16_le(sa){
    //console.log(sa)
    var str = sa.map(function(e){
      return (String.fromCharCode((e>>8),(e%256)));
    }).join("");
    return str;
    //return val
  }
  static dsp_name_u16_le(sa){
    var str = sa.map(function(e){
      return (String.fromCharCode((e>>8),(e%256)));
    }).join("");
    return str;
    //return val
  }
  static dsp_serno_u16_le(sa){
    var str = sa.map(function(e){
      return (String.fromCharCode((e>>8),(e%256)));
    }).join("");
    return str;
    //return val
  }
  static rec_date(val){
    //needs to be swapped..
    //0xac26 -> 0x26ac
    var dd = val & 0x1f;
    var mm = (val >> 5) & 0xf
    var yyyy = ((val>>9) & 0x7f) + 1996
    return yyyy.toString() + '/' + mm.toString() + '/' + dd.toString();
  }
  static phase_spread(val){
    return Math.round(Params.frac_value(val)*45)
  }
  static phase_wet(val){
    return ((Params.frac_value(val) * 45)).toFixed(2);
  }
  static phase_dry(val){
    if(((Params.frac_value(val) * 45)+90) <= 135){
      return ((Params.frac_value(val) * 45)+90).toFixed(2); 
    }
    else{
      return ((Params.frac_value(val) * 45)).toFixed(2);
      
    }

  }
  static phase(val, wet){
    //console.log(wet);
    if(wet==0){
      return Params.phase_dry(val);
    }else{
      return Params.phase_wet(val);
    }
  }
  static rej_del(ticks, tack){
    if(tack==0){
      return (ticks/231.0).toFixed(2); //2 decimal float
    }else{
      return ticks;
    }
  }
  static belt_speed(tpm, metric, tack){
    //console.log(tpm);
    if(tack!=0){

      return tpm;
    }
    var speed = (231.0/tpm) * 60;
    if(metric==0){
      return (speed*3.281).toFixed(1) + ' ft/min'
    }else{
      return speed.toFixed(1) + ' M/min'
    }
  
  }
  static password8(words){
  
    var res = words.map(function(w){
      return ((w & 0xffff).toString(16)) //hex format string
    }).join(',')
  //  console.log(res);
    return(res)

  }
  static rej_chk(rc1, rc2){
    if (rc2==0){
      if(rc1==0){
        return 0
      }else{
        return 1
      }
    }else{
      return 2
    }
  }
  static rej_mode(photo, rev){
    if (rev==0){
      if (photo==0){
        return 0;
      }else{
        return 1;
      }
    }else{
      return 2;
    }
  }

  static rej_latch(latch, toggle){
    if (toggle==0){
      if (latch==0){
        return 0;
      }else{
        return 1;
      }
    }else{
      return 2;
    }
  }
  static prod_name(sa){
    var str = sa.map(function(e){
      return (String.fromCharCode((e>>8),(e%256)));
    }).join("");
    return str;
    //return val;
  }


  static peak_mode(eye, time){
    if (eye==0){
      if (time==0){
        return 0;
      }else{
        return 2;
      }
    }else{
      return 1;
    }
  }


  static eye_rej(photo, lead, width){
    if (photo==0){
      return 3;
    }else{
      if(lead==0){
        if(width==0){
          return 0;
        }else{
          return 2;
        }
      }else{
        return 1;
      }
    }
  }
  static phase_mode(wet, patt){
    //console.log(patt)
    if (patt==0){
      if (wet==0){
        return 0;
      }
      else{
        return 1;
      }
    }else{
      return 2;
    }
  }
  
  static bit_array(val){
    if(val == 0){
      return 0;
    }else{
      var i = 0;
      while(i<16 && ((val>>i) & 1) == 0){
        i++;
      }
      i++; //1 based index
      return i;
    }
  }

  static patt_frac(val){
    return (val/10.0).toFixed(1);
  }

  static eye_rej_mode(val, photo, width){
    if(photo == 0){
      return 3;
    }else{
      if (val == 0){
        if (width == 0){
          return 0;
        }else{
          return 2;
        }
      }else{
        return 1;
      }
    }
    
  }

  static  swap16(val){
      return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF);
  }

  static  convert_word_array_BE(byteArr){
    var b = new Buffer(byteArr)
    var length = byteArr.length/2;
    var wArray = []
    //console.log(length)
    for(var i = 0; i<length; i++){
      wArray.push(b.readUInt16BE(i*2));
    }
    //console.log(wArray)
    return wArray;

  }

  static convert_word_array_LE(byteArr){
    var b = new Buffer(byteArr)
    var length = byteArr.length/2;
    var wArray = []
    //console.log(length)
    for(var i = 0; i<length; i++){
      wArray.push(b.readUInt16LE(i*2));
    }
    //console.log(wArray)
    return wArray;

  }
  static ipv4_address(words){
    //todo
    //console.log(ip)
    //return ip
    var str_Words = words.map(function(w){
      return [(w>>8)&0xff,w&0xff].join('.')
    })
    return str_Words.join('.')
  }
}

function toArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }
    return ab;
}
function uintToInt(uint, nbit) {
    nbit = +nbit || 32;
    if (nbit > 32) throw new RangeError('uintToInt only supports ints up to 32 bits');
    uint <<= 32 - nbit;
    uint >>= 32 - nbit;
    return uint;
}
function getVal(arr, rec, key, pVdef){
    var param = pVdef[rec][key]
    if(param['@bit_len']>16){

      return wordValue(arr, param)
    }else{
      var val;
      if((param['@bit_pos'] + param['@bit_len']) > 16){
        var wd = (Params.swap16(arr[param['@i_var']+1])<<16) | Params.swap16((arr[param['@i_var']]))
        val = (wd >> param["@bit_pos"]) & ((1<<param["@bit_len"])-1)
        
      }else{
        val = Params.swap16(arr[param["@i_var"]]);
      } 
      if(param["@bit_len"] < 16){
        val = (val >> param["@bit_pos"]) & ((1<<param["@bit_len"])-1)
      }
      return val;
    }
}
function wordValue(arr, p){

    var n = Math.floor(p["@bit_len"]/16);
    var sa = arr.slice(p["@i_var"], p["@i_var"]+n)
    if(p['@type']){
      return Params[p['@type']](sa)
    }else{
      var str = sa.map(function(e){
      return (String.fromCharCode((e>>8),(e%256)));
    }).join("");
    return str; 
    }
    
}
function isDiff(x, y){
    for(var p in x){
      if(typeof y[p] != 'undefined'){
        if(!(x[p] == y[p])){
          return true
        }
      }else{
        return true
      }
    }
    return false;
}
function dsp_rpc_paylod_for (n_func, i16_args, byte_data) {
        var rpc = [];
        var n_args = i16_args.length;
        var bytes = [];
        if (n_args > 3) n_args = 3;
        if (typeof byte_data == "string") {
          for(var i=0; i<byte_data.length; i++) {
              bytes.push(byte_data.charCodeAt(i));
          }         
        } else if (byte_data instanceof Array) {
          bytes = byte_data;
         }
        rpc[0] = n_func;
        rpc[1] = n_args;
        if (bytes.length > 0) rpc[1] += 4;
        var j=2;
        for(var i=0; i<n_args; i++) {
          rpc[j] = i16_args[i] & 0xff; j+= 1;
          rpc[j] = (i16_args[i] >> 8) & 0xff; j+= 1;
        }
        if (bytes.length > 0) rpc = rpc.concat(bytes);
        
        var cs = fletcherCheckBytes(rpc);
        var cs1=255-((cs[0]+cs[1])%255); 
        var cs2=255-((cs[0]+cs1)%255);
        rpc.push(cs1);
        rpc.push(cs2);
        return rpc;
}
function fletcherCheckBytes (data) {
        var c1=0, c2=0;
        for(var i=0; i<data.length; i++) {
          c1 += data[i]; if (c1 >=255) c1 -= 255;
          c2 += c1;      if (c2 >=255) c2 -= 255;
        }
        return [c1,c2];
      }


var socket = io();

var sysSettings = {};
var prodSettings ={};
var framSettings ={};
var combinedSettings = [];
var liveTimer = {}
var myTimers = {}

var located = false;
var cnt = 0;

socket.on('vdef', function(vdf){

var json = vdf[0];
_Vdef = json
console.log(_Vdef)

  var res = [];
    res[0] = {};
    res[1] = {};
    res[2] = {};
    res[3] = {};
   var nVdf = {};
    nVdf['Other'] = [{}];
    nVdf['Password'] = [{}];
    nVdf['Rej Setup'] = [{}];
    nVdf['Faults'] = [{}];
    nVdf['Output'] = [{}];
    nVdf['Sensitivity'] = [{}];
    nVdf['Test'] = [{}];
    nVdf['Calibration'] = [{}];
    nVdf['Input'] = [{}];
    nVdf['Output'] = [{}];
    nVdf['Interceptor'] = {}

    json["@params"].forEach(function(p ){
      res[p["@rec"]][p["@name"]] = p;
      var int = false;

     var nm = p['@name'];
     var irg = /(_(A|B))$/
     if(nm.match(irg)){
      //console.log(nm.slice(0,-2))
      if(!nVdf['Interceptor'][nm.slice(0,-2)]){
        nVdf['Interceptor'][nm.slice(0,-2)] = {}
      }
      nVdf['Interceptor'][nm.slice(0,-2)][nm.slice(-1)] = p;
      int = true;
     }
     var aarg = /(_(D)_(D))$/
     var otherFlag = true;
     if(p["@rec"]!=2){
     for(var o in value_groups){
  if(o == 'Faults'){
      if(nm.indexOf('FaultMask')!= -1){
        nVdf[o].push(p);
        otherFlag = false;
        break;
      }
     }else if(o == 'Test'){
      if(nm.indexOf('TestConfig')!= -1){
        nVdf[o].push(p);
        otherFlag = false;
        break;
      }
     }else if(o == 'Input'){
      if(nm.indexOf('INPUT')!= -1){
      //  console.log([o,p])
          nVdf[o].push(p);
        otherFlag = false;
        break;
      } 
     }else if(o == 'Output'){
      if(nm.indexOf('OUT')!= -1){
          nVdf[o].push(p);
        otherFlag = false;
        break;
      }
     }
     if(value_groups[o].indexOf(nm) != -1){
      nVdf[o].push(p);
      otherFlag = false;
      break;
     }else if(int){
      if(value_groups[o].indexOf(nm.slice(0,-2)) != -1){
        if(!nVdf[o][0][nm.slice(0,-2)]){
          nVdf[o][0][nm.slice(0,-2)] = {}
        }
        nVdf[o][0][nm.slice(0,-2)][nm.slice(-1)] = p;
        //nVdf[o].push(p);
        otherFlag = false;
          break;
      }
     }

   }
   if(otherFlag){  
    if(p["@rec"] <2){
      nVdf['Other'].push(p)
    }
   }
}
    });
    res[4] = json["@deps"];
    res[5] = json["@labels"]
    res[6] = [];
   for(var par in res[2]){  
      if(par.indexOf('Fault') != -1){
        console.log("fault found")
        res[6].push(par)
      }
    }
    _pVdef = res;
    vdefList[json['@version']] = [json, res, nVdf]
    vdefByIp[vdf[1]] = [json, res, nVdf]
    isVdefSet = true;
    console.log(nVdf['Interceptor'])

})

    </script>
  <!--  <script type="text/babel" src="scripts/components.js"></script>-->
   <!-- <script type="text/babel" src="scripts/app.js"></script>-->
   <script type="text/javascript" src="bundle.js"></script>
     </body>
</html>
